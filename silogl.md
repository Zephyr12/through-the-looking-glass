Through The Silicon Looking Glass
=================================

## Abstract
There are many parts of the modern world that seem to run on a strange type of magic. A sorcery based on doped silicates and rare earths. With a little attention this magic looses it's sheen and the sufficiently advanced technology can be revealed. In this article I will cover how some of the most fundamental parts of modern computing can be demystified.

### Program Execution
To run a program it must be read from *Secondary storage*, storage that is not immediately available to the processor. This is because *Primary storage*, storage that is directly available to the processor, such as *Random Access Memory, RAM* or Cache cannot survive reboots i.e. when you reboot the computer the data does not persist. So upon booting the CPU asks the primary storage for the first *Partition* on it. This partition usually contains the *Basic Input Output System, BIOS* on older computers or the *Extended Firmware Interface, EFI* loader on newer ones. The purpose of these peices of software is to set up hardware in a way that allow it to be used by the *Operating System*, and usually to start the *Boot loader* which finally loads the *Operating System*: all this, by the way, happens in a fraction of a second well before any `Windows` logo shows up. Lets go into one of the smallest parts of the bios, the single *Instruction*; Lets assume that the CPU has just finished handling the last instruction. A *Register*, a fast segment of memory under direct control of the CPU, called the *Program counter* is copied into another register called the *Memory address register*. The contents of this register is sent to the RAM on a pathway called an *Address bus*, busses used to be parrelel bundles of cable but they like other old parts of compter archetecture have been updated and nowerdays they refer to any way of transferring signals from one component to another. Once at the RAM, the *Ram controller* searches the RAM for the data and sends it back to the CPU on the *Data bus*. While it arrives the CPU, the program counter is incremented the data from the data bus is copied into the *Memory Buffer Register*; from here it is copied by the CPU's *Control Unit* into the *Current Instuction Register*. The control unit then splits up the instruction into *Opcode* and *Operand* 


### User Input
When you press the key on a key board a *Membrane* under the key is compressed. This compression generates a signal which is sent to the *Microprocessor* on the keyboard itself. The microprocessor handles and processes this data into a form that the rest of the computer can read. This is then sent to the aptly named *Programmable interrupt controller, PIC* in the form of *Scan codes*, which are usually a list of numbers indicating which keys have been pressed. Once at the scan codes have arrived the controller sends the *Central Processing Unit, CPU* an *Interrupt*, a signal that tells the CPU to drop everything and handle the request. Upon finishing it's current instruction the CPU checks the PIC for an interrupt and if one has happened the CPU jumps to the location in memory that contains the part of the *Operating System, OS* that handles that type of request. Once the operating system acknowledges the interrupt it then gathers data i.e. what keys were pressed, which modifiers were pressed (Shift, Control), bundles this data up and sends it to the currently running program. This program then decides how to handle the *Key-event*, e.g. to display it on screen in a Search Bar. On average this happens 3-4 times a second for the keyboard, and much more often for things like mouse movement which follows a similar process.


### Visual Output


### A Cat Photo
